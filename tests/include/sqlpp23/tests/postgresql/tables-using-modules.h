#pragma once

// clang-format off
// generated by ./scripts/sqlpp23-ddl2cpp --path-to-ddl tests/include/sqlpp23/tests/postgresql/tables.sql --path-to-header tests/include/sqlpp23/tests/postgresql/tables-using-modules.h --namespace test --assume-auto-id --use-import-sqlpp23 --generate-table-creation-helper

#include <optional>
import sqlpp23.core;

#include <sqlpp23/core/name/create_name_tag.h>

namespace test {
  template<typename Db>
  void createTabFoo(Db& db) {
    db(R"+++(DROP TABLE IF EXISTS tab_foo)+++");
    db(R"+++(CREATE TABLE tab_foo
(
  id bigserial PRIMARY KEY,
  text_nn_d varchar(255) NOT NULL DEFAULT '',
  int_n bigint,
  double_n double precision,
  int_nn_u bigint UNIQUE,
  bool_n bool,
  blob_n bytea,
  UNIQUE(id, int_nn_u) -- to test multi-argument on_confict
))+++");
  }

  struct TabFoo_ {
    struct Id {
      SQLPP_CREATE_NAME_TAG_FOR_SQL_AND_CPP(id, id);
      using data_type = ::sqlpp::integral;
      using has_default = std::true_type;
    };
    struct TextNnD {
      SQLPP_CREATE_NAME_TAG_FOR_SQL_AND_CPP(text_nn_d, textNnD);
      using data_type = ::sqlpp::text;
      using has_default = std::true_type;
    };
    struct IntN {
      SQLPP_CREATE_NAME_TAG_FOR_SQL_AND_CPP(int_n, intN);
      using data_type = std::optional<::sqlpp::integral>;
      using has_default = std::true_type;
    };
    struct DoubleN {
      SQLPP_CREATE_NAME_TAG_FOR_SQL_AND_CPP(double_n, doubleN);
      using data_type = std::optional<::sqlpp::floating_point>;
      using has_default = std::true_type;
    };
    struct IntNnU {
      SQLPP_CREATE_NAME_TAG_FOR_SQL_AND_CPP(int_nn_u, intNnU);
      using data_type = std::optional<::sqlpp::integral>;
      using has_default = std::true_type;
    };
    struct BoolN {
      SQLPP_CREATE_NAME_TAG_FOR_SQL_AND_CPP(bool_n, boolN);
      using data_type = std::optional<::sqlpp::boolean>;
      using has_default = std::true_type;
    };
    struct BlobN {
      SQLPP_CREATE_NAME_TAG_FOR_SQL_AND_CPP(blob_n, blobN);
      using data_type = std::optional<::sqlpp::blob>;
      using has_default = std::true_type;
    };
    SQLPP_CREATE_NAME_TAG_FOR_SQL_AND_CPP(tab_foo, tabFoo);
    template<typename T>
    using _table_columns = sqlpp::table_columns<T,
               Id,
               TextNnD,
               IntN,
               DoubleN,
               IntNnU,
               BoolN,
               BlobN>;
    using _required_insert_columns = sqlpp::detail::type_set<>;
  };
  using TabFoo = ::sqlpp::table_t<TabFoo_>;

  template<typename Db>
  void createTabBar(Db& db) {
    db(R"+++(DROP TABLE IF EXISTS tab_bar)+++");
    db(R"+++(CREATE TABLE tab_bar
(
  id bigserial PRIMARY KEY,
  text_n varchar(255) NULL,
  bool_nn bool NOT NULL DEFAULT false,
  int_n int
))+++");
  }

  struct TabBar_ {
    struct Id {
      SQLPP_CREATE_NAME_TAG_FOR_SQL_AND_CPP(id, id);
      using data_type = ::sqlpp::integral;
      using has_default = std::true_type;
    };
    struct TextN {
      SQLPP_CREATE_NAME_TAG_FOR_SQL_AND_CPP(text_n, textN);
      using data_type = std::optional<::sqlpp::text>;
      using has_default = std::true_type;
    };
    struct BoolNn {
      SQLPP_CREATE_NAME_TAG_FOR_SQL_AND_CPP(bool_nn, boolNn);
      using data_type = ::sqlpp::boolean;
      using has_default = std::true_type;
    };
    struct IntN {
      SQLPP_CREATE_NAME_TAG_FOR_SQL_AND_CPP(int_n, intN);
      using data_type = std::optional<::sqlpp::integral>;
      using has_default = std::true_type;
    };
    SQLPP_CREATE_NAME_TAG_FOR_SQL_AND_CPP(tab_bar, tabBar);
    template<typename T>
    using _table_columns = sqlpp::table_columns<T,
               Id,
               TextN,
               BoolNn,
               IntN>;
    using _required_insert_columns = sqlpp::detail::type_set<>;
  };
  using TabBar = ::sqlpp::table_t<TabBar_>;

  template<typename Db>
  void createTabDateTime(Db& db) {
    db(R"+++(DROP TABLE IF EXISTS tab_date_time)+++");
    db(R"+++(CREATE TABLE tab_date_time
(
  date_n date,
  timestamp_n timestamp,
  time_n time,
  timestamp_n_tz timestamp with time zone,
  time_n_tz time with time zone
))+++");
  }

  struct TabDateTime_ {
    struct DateN {
      SQLPP_CREATE_NAME_TAG_FOR_SQL_AND_CPP(date_n, dateN);
      using data_type = std::optional<::sqlpp::date>;
      using has_default = std::true_type;
    };
    struct TimestampN {
      SQLPP_CREATE_NAME_TAG_FOR_SQL_AND_CPP(timestamp_n, timestampN);
      using data_type = std::optional<::sqlpp::timestamp>;
      using has_default = std::true_type;
    };
    struct TimeN {
      SQLPP_CREATE_NAME_TAG_FOR_SQL_AND_CPP(time_n, timeN);
      using data_type = std::optional<::sqlpp::time>;
      using has_default = std::true_type;
    };
    struct TimestampNTz {
      SQLPP_CREATE_NAME_TAG_FOR_SQL_AND_CPP(timestamp_n_tz, timestampNTz);
      using data_type = std::optional<::sqlpp::timestamp>;
      using has_default = std::true_type;
    };
    struct TimeNTz {
      SQLPP_CREATE_NAME_TAG_FOR_SQL_AND_CPP(time_n_tz, timeNTz);
      using data_type = std::optional<::sqlpp::time>;
      using has_default = std::true_type;
    };
    SQLPP_CREATE_NAME_TAG_FOR_SQL_AND_CPP(tab_date_time, tabDateTime);
    template<typename T>
    using _table_columns = sqlpp::table_columns<T,
               DateN,
               TimestampN,
               TimeN,
               TimestampNTz,
               TimeNTz>;
    using _required_insert_columns = sqlpp::detail::type_set<>;
  };
  using TabDateTime = ::sqlpp::table_t<TabDateTime_>;

  template<typename Db>
  void createBlobSample(Db& db) {
    db(R"+++(DROP TABLE IF EXISTS blob_sample)+++");
    db(R"+++(CREATE TABLE blob_sample (
  id bigserial PRIMARY KEY,
  data bytea
))+++");
  }

  struct BlobSample_ {
    struct Id {
      SQLPP_CREATE_NAME_TAG_FOR_SQL_AND_CPP(id, id);
      using data_type = ::sqlpp::integral;
      using has_default = std::true_type;
    };
    struct Data {
      SQLPP_CREATE_NAME_TAG_FOR_SQL_AND_CPP(data, data);
      using data_type = std::optional<::sqlpp::blob>;
      using has_default = std::true_type;
    };
    SQLPP_CREATE_NAME_TAG_FOR_SQL_AND_CPP(blob_sample, blobSample);
    template<typename T>
    using _table_columns = sqlpp::table_columns<T,
               Id,
               Data>;
    using _required_insert_columns = sqlpp::detail::type_set<>;
  };
  using BlobSample = ::sqlpp::table_t<BlobSample_>;

  template<typename Db>
  void createTabExcept(Db& db) {
    db(R"+++(DROP TABLE IF EXISTS tab_except)+++");
    db(R"+++(CREATE TABLE tab_except (
  int_small_n_u smallint UNIQUE,
  text_short_n text CHECK( length(text_short_n) < 5 )
))+++");
  }

  struct TabExcept_ {
    struct IntSmallNU {
      SQLPP_CREATE_NAME_TAG_FOR_SQL_AND_CPP(int_small_n_u, intSmallNU);
      using data_type = std::optional<::sqlpp::integral>;
      using has_default = std::true_type;
    };
    struct TextShortN {
      SQLPP_CREATE_NAME_TAG_FOR_SQL_AND_CPP(text_short_n, textShortN);
      using data_type = std::optional<::sqlpp::text>;
      using has_default = std::true_type;
    };
    SQLPP_CREATE_NAME_TAG_FOR_SQL_AND_CPP(tab_except, tabExcept);
    template<typename T>
    using _table_columns = sqlpp::table_columns<T,
               IntSmallNU,
               TextShortN>;
    using _required_insert_columns = sqlpp::detail::type_set<>;
  };
  using TabExcept = ::sqlpp::table_t<TabExcept_>;

  template<typename Db>
  void createTabDepartment(Db& db) {
    db(R"+++(DROP TABLE IF EXISTS tab_department)+++");
    db(R"+++(CREATE TABLE tab_department (
  id SERIAL PRIMARY KEY,
  name CHAR(100),
  division VARCHAR(255) NOT NULL DEFAULT 'engineering'
))+++");
  }

  struct TabDepartment_ {
    struct Id {
      SQLPP_CREATE_NAME_TAG_FOR_SQL_AND_CPP(id, id);
      using data_type = ::sqlpp::integral;
      using has_default = std::true_type;
    };
    struct Name {
      SQLPP_CREATE_NAME_TAG_FOR_SQL_AND_CPP(name, name);
      using data_type = std::optional<::sqlpp::text>;
      using has_default = std::true_type;
    };
    struct Division {
      SQLPP_CREATE_NAME_TAG_FOR_SQL_AND_CPP(division, division);
      using data_type = ::sqlpp::text;
      using has_default = std::true_type;
    };
    SQLPP_CREATE_NAME_TAG_FOR_SQL_AND_CPP(tab_department, tabDepartment);
    template<typename T>
    using _table_columns = sqlpp::table_columns<T,
               Id,
               Name,
               Division>;
    using _required_insert_columns = sqlpp::detail::type_set<>;
  };
  using TabDepartment = ::sqlpp::table_t<TabDepartment_>;

} // namespace test
